;; bioseq-mode.el -- Major mode for viewing and manipulating DNA and 
;; peptide sequences.
;; Written by Michael N. Bramson, released into the public domain

;; Installation instructions:
;; First, this file must be saved somewhere in the emacs load path.
;; One way to do this, in Linux, is to save it in ~/.emacs.d and add the
;; following line to ~/.emacs :
;; (add-to-list 'load-path "~/.emacs.d/")
;; Then we want to autoload the mode when reading a file ending in .fas,
;; .fasta, or .embs, so the following must also be added to the .emacs file:
;; (autoload 'bioseq-mode "bioseq-mode" "Major mode for biological sequences" t)
;; (add-to-list 'auto-mode-alist 
;; 	     '("\\.\\(fas\\|fasta\\|embs\\)\\'" . bioseq-mode))

;; Most functions require a special file format, but FASTA files can be
;; automatically converted using C-c C-f or bioseq-convert-fasta.

;; .embs is the file extension for files that are formatted for use by
;; bioseq-mode. The most important formatting feature is that each line of
;; sequence is prefaced by a 3-digit numeric identifier (e.g. 001), followed
;; by a character indicating the type of sequence: '+' for DNA, '$' for RNA,
;; '#' for peptides. Other line types are generated by various functions.
;; Further identifying information should be stored on a separate line that 
;; shares the same 3-digit identifier, followed by '>'.
;; Thus, a very simple file might look like:
;; 001>sequence00183847|20120712
;; 001+CTGGGACCTAGCATGGCCATGACTTCCCCATA
;; These lines need not appear next to each other. It may be useful to clump
;; all ID lines together at the top, with lines of sequence below.
;; Further, multiple lines could share the same 3-digit identifier, such as if 
;; a line of DNA is followed by a line with the amino acid translation.
;; In fact, the order of lines does not matter at all except when converting
;; to FASTA format. Notes, sequence fragments, rulers, etc. can all be
;; interspersed wherever it is convenient, which is one of the strengths of
;; editing sequences in a text editor like emacs.

;; To convert back to FASTA format, a more rigid structure must be adhered to.
;; All ID lines ("###>name") must appear together at the top, followed
;; immediately by the corresponding sequence lines, in the correct order.
;; The conversion function counts the number of ID lines, checks to make sure
;; there are enough lines below (hopefully containing the sequences), and
;; deletes anything below those.
;; A properly-formatted file would look something like:
;; 001>sequence00183847|20120712
;; 002>sequence00282395|20120711
;; 001+CTGGGACCTAGCATGGCCATGACTTCCCCATA
;; 002+AGTATCGCGGCCCTAGTACTGACTGATTC

;; Note that most functions do not check to make sure that the region or
;; line being acted upon is properly formatted for the function, which may
;; result in aberrant behavior if functions are called out of context.

;; Obviously, the utility of editing sequence data with emacs and bioseq-mode
;; is greatly enhanced by an understanding of normal emacs use, especially
;; functions like keyboard macros.

;; There is no current plan to integrate external software packages such
;; as BLAST or Clustal, but practically everything can read FASTA files.

;; There are very likely major bugs and violations of emacs conventions in the
;; current version of this mode, although I have attempted to comply with
;; keybinding conventions. C-<right> and C-<left> have been overridden to
;; provide more appropriate functionality, however (moving 100 characters
;; forwards or backwards).

;; Version 0.11, March 2014

;; Features still to be implemented:
;; RNA support
;; Conversion of .aln files from Clustal

(defvar bioseq-mode-hook nil "Hook to set up bioseq-mode.")

(defvar master-sequence "" "Sequence to compare to for conservation.")

(defvar bioseq-codon-table
  '(("TTT" . "F") ("TTC" . "F") ("TTA" . "L") ("TTG" . "L")
    ("TCT" . "S") ("TCC" . "S") ("TCA" . "S") ("TCG" . "S")
    ("TAT" . "Y") ("TAC" . "Y") ("TAA" . "*") ("TAG" . "*")
    ("TGT" . "C") ("TGC" . "C") ("TGA" . "*") ("TGG" . "W")
    ("CTT" . "L") ("CTC" . "L") ("CTA" . "L") ("CTG" . "L")
    ("CCT" . "P") ("CCC" . "P") ("CCA" . "P") ("CCG" . "P")
    ("CAT" . "H") ("CAC" . "H") ("CAA" . "Q") ("CAG" . "Q")
    ("CGT" . "R") ("CGC" . "R") ("CGA" . "R") ("CGG" . "R")
    ("ATT" . "I") ("ATC" . "I") ("ATA" . "I") ("ATG" . "M")
    ("ACT" . "T") ("ACC" . "T") ("ACA" . "T") ("ACG" . "T")
    ("AAT" . "N") ("AAC" . "N") ("AAA" . "K") ("AAG" . "K")
    ("AGT" . "S") ("AGC" . "S") ("AGA" . "R") ("AGG" . "R")
    ("GTT" . "V") ("GTC" . "V") ("GTA" . "V") ("GTG" . "V")
    ("GCT" . "A") ("GCC" . "A") ("GCA" . "A") ("GCG" . "A")
    ("GAT" . "D") ("GAC" . "D") ("GAA" . "E") ("GAG" . "E")
    ("GGT" . "G") ("GGC" . "G") ("GGA" . "G") ("GGG" . "G")
    ("TTY" . "F") ("TTR" . "L") ("CTR" . "L") ("CTY" . "L")
    ("CTS" . "L") ("CTW" . "L") ("CTK" . "L") ("CTM" . "L")
    ("CTB" . "L") ("CTD" . "L") ("CTH" . "L") ("CTV" . "L")
    ("CTN" . "L") ("YTA" . "L") ("YTG" . "L") ("YTR" . "L")
    ("ATY" . "I") ("ATW" . "I") ("ATM" . "I") ("ATH" . "I")
    ("GTR" . "V") ("GTY" . "V") ("GTS" . "V") ("GTW" . "V")
    ("GTK" . "V") ("GTM" . "V") ("GTB" . "V") ("GTD" . "V")
    ("GTH" . "V") ("GTV" . "V") ("GTN" . "V") ("TCR" . "S")
    ("TCY" . "S") ("TCS" . "S") ("TCW" . "S") ("TCK" . "S")
    ("TCM" . "S") ("TCB" . "S") ("TCD" . "S") ("TCH" . "S")
    ("TCV" . "S") ("TCN" . "S") ("CCR" . "P") ("CCY" . "P")
    ("CCS" . "P") ("CCW" . "P") ("CCK" . "P") ("CCM" . "P")
    ("CCB" . "P") ("CCD" . "P") ("CCH" . "P") ("CCV" . "P")
    ("CCN" . "P") ("ACR" . "T") ("ACY" . "T") ("ACS" . "T")
    ("ACW" . "T") ("ACK" . "T") ("ACM" . "T") ("ACB" . "T")
    ("ACD" . "T") ("ACH" . "T") ("ACV" . "T") ("ACN" . "T")
    ("GCR" . "A") ("GCY" . "A") ("GCS" . "A") ("GCW" . "A")
    ("GCK" . "A") ("GCM" . "A") ("GCB" . "A") ("GCD" . "A")
    ("GCH" . "A") ("GCV" . "A") ("GCN" . "A") ("TAY" . "Y")
    ("TAR" . "*") ("CAY" . "H") ("CAR" . "Q") ("AAY" . "N")
    ("AAR" . "K") ("GAY" . "D") ("GAR" . "E") ("TGY" . "C")
    ("CGR" . "R") ("CGY" . "R") ("CGS" . "R") ("CGW" . "R")
    ("CGK" . "R") ("CGM" . "R") ("CGB" . "R") ("CGD" . "R")
    ("CGH" . "R") ("CGV" . "R") ("CGN" . "R") ("AGY" . "S")
    ("MGA" . "R") ("MGG" . "R") ("MGR" . "R") ("GGR" . "G")
    ("GGY" . "G") ("GGS" . "G") ("GGW" . "G") ("GGK" . "G")
    ("GGM" . "G") ("GGB" . "G") ("GGD" . "G") ("GGH" . "G")
    ("GGV" . "G") ("GGN" . "G") ("TRA" . "*"))
  "Association list of DNA codons and their translations.")

(defvar bioseq-complement-table
  '(("A" . "T") ("T" . "A") ("C" . "G") ("G" . "C")
    ("R" . "Y") ("Y" . "R") ("S" . "S") ("W" . "W")
    ("K" . "M") ("M" . "K") ("B" . "V") ("V" . "B")
    ("D" . "H") ("H" . "D") ("N" . "N") ("-" . "-"))
  "Association list of DNA residues and their complements, including IUPAC
ambiguity codes.")

;; Nucleotide faces
(defface bioseq-mode-a
  '((((min-colors 8)) :foreground "blue"))
  "Face for As in bioseq-mode")

(defface bioseq-mode-g
  '((((min-colors 8)) :foreground "forest green"))
  "Face for Gs in bioseq-mode")

(defface bioseq-mode-t
  '((((min-colors 8)) :foreground "red"))
  "Face for Ts in bioseq-mode")

(defface bioseq-mode-c
  '((((min-colors 8)) :foreground "black"))
  "Face for Cs in bioseq-mode")

(defface bioseq-mode-ambig
  '((((min-colors 8)) :foreground "purple"))
  "Face for ambiguities in bioseq-mode")

(defface bioseq-mode-gap
  '((((min-colors 8)) :foreground "gray"))
  "Face for gaps in bioseq-mode")


;; Amino acid faces
;; Each residue gets its own face in order to make modification easier,
;; but some of the colors may be the same.
;; The current color scheme is a modification of the ClustalX scheme.
(defface bioseq-mode-aa-r
  '((((min-colors 8)) :foreground "red"))
  "Face for arginine in bioseq-mode")

(defface bioseq-mode-aa-h
  '((((min-colors 8)) :foreground "cyan4"))
  "Face for histidine in bioseq-mode")

(defface bioseq-mode-aa-k
  '((((min-colors 8)) :foreground "red"))
  "Face for lysine in bioseq-mode")

(defface bioseq-mode-aa-d
  '((((min-colors 8)) :foreground "magenta"))
  "Face for aspartic acid in bioseq-mode")

(defface bioseq-mode-aa-e
  '((((min-colors 8)) :foreground "magenta"))
  "Face for glutamic acid in bioseq-mode")

(defface bioseq-mode-aa-s
  '((((min-colors 8)) :foreground "forest green"))
  "Face for serine in bioseq-mode")

(defface bioseq-mode-aa-t
  '((((min-colors 8)) :foreground "forest green"))
  "Face for threonine in bioseq-mode")

(defface bioseq-mode-aa-n
  '((((min-colors 8)) :foreground "forest green"))
  "Face for asparagine in bioseq-mode")

(defface bioseq-mode-aa-q
  '((((min-colors 8)) :foreground "forest green"))
  "Face for glutamine in bioseq-mode")

(defface bioseq-mode-aa-c
  '((((min-colors 8)) :foreground "salmon"))
  "Face for cysteine in bioseq-mode")

(defface bioseq-mode-aa-g
  '((((min-colors 8)) :foreground "dark orange"))
  "Face for glycine in bioseq-mode")

(defface bioseq-mode-aa-p
  '((((min-colors 8)) :foreground "goldenrod"))
  "Face for proline in bioseq-mode")

(defface bioseq-mode-aa-a
  '((((min-colors 8)) :foreground "blue"))
  "Face for alanine in bioseq-mode")

(defface bioseq-mode-aa-v
  '((((min-colors 8)) :foreground "blue"))
  "Face for valine in bioseq-mode")

(defface bioseq-mode-aa-i
  '((((min-colors 8)) :foreground "blue"))
  "Face for isoleucine in bioseq-mode")

(defface bioseq-mode-aa-l
  '((((min-colors 8)) :foreground "blue"))
  "Face for leucine in bioseq-mode")

(defface bioseq-mode-aa-m
  '((((min-colors 8)) :foreground "blue"))
  "Face for methionine in bioseq-mode")

(defface bioseq-mode-aa-f
  '((((min-colors 8)) :foreground "blue"))
  "Face for phenylalanine in bioseq-mode")

(defface bioseq-mode-aa-y
  '((((min-colors 8)) :foreground "cyan4"))
  "Face for tyrosine in bioseq-mode")

(defface bioseq-mode-aa-w
  '((((min-colors 8)) :foreground "blue"))
  "Face for tryptophan in bioseq-mode")

;; Specify the coloration of nucleotides and amino acids on a
;; properly-formatted sequence line.
;; Don't ask me to explain why this regular expression syntax works.
(defvar bioseq-font-lock-keywords
  '(("^[0-9A-Z][0-9A-Z][0-9A-Z][=\\+]"
    ("A" nil nil (0 'bioseq-mode-a))
    ("G" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-g))
    ("T" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-t))
    ("C" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-c))
    ("[RYSWKMBDHVN]" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-ambig))
    ("[\-\.]" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-gap)))
    ("^[0-9A-Z][0-9A-Z][0-9A-Z][#&]"
    ("R" nil nil (0 'bioseq-mode-aa-r))
    ("H" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-h))
    ("K" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-k))
    ("D" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-d))
    ("E" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-e))
    ("S" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-s))
    ("T" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-t))
    ("N" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-n))
    ("Q" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-q))
    ("C" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-c))
    ("G" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-g))
    ("P" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-p))
    ("A" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-a))
    ("V" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-v))
    ("I" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-i))
    ("L" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-l))
    ("M" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-m))
    ("F" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-f))
    ("Y" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-y))
    ("W" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-aa-w))
    ("[\-\.]" (progn (beginning-of-line) (forward-char 4)) nil (0 'bioseq-mode-gap)))))

(defvar bioseq-mode-map nil "Keymap for bioseq-mode")
(if bioseq-mode-map
  () ; Do not change the keymap if it's already set up
  (setq bioseq-mode-map (make-sparse-keymap))
  ;; Define custom keybindings for the mode
  (define-key bioseq-mode-map (kbd "C-c C-f") 'bioseq-convert-fasta)
  (define-key bioseq-mode-map (kbd "C-c C-n") 'bioseq-add-ruler)
  (define-key bioseq-mode-map (kbd "C-c C-t") 'bioseq-translate-line)
  (define-key bioseq-mode-map (kbd "C-c >") 'bioseq-aa-space-line)
  (define-key bioseq-mode-map (kbd "C-c <") 'bioseq-remove-spaces-line)
  (define-key bioseq-mode-map (kbd "C-c C-r") 'bioseq-reverse-complement-line)
  (define-key bioseq-mode-map (kbd "C-c C-b") 'bioseq-reverse-line)
  (define-key bioseq-mode-map (kbd "C-c C-c") 'bioseq-complement-line)
  (define-key bioseq-mode-map (kbd "C-c C-m") 'bioseq-set-master-sequence)
  (define-key bioseq-mode-map (kbd "C-c C-c") 'bioseq-compare-seqs)
  (define-key bioseq-mode-map (kbd "C-c C-a") 'bioseq-align-to-master)
  (define-key bioseq-mode-map (kbd "C-c C-e") 'bioseq-convert-to-fasta)
  (define-key bioseq-mode-map (kbd "C-<left>") 'bioseq-backward-hundred)
  (define-key bioseq-mode-map (kbd "C-<right>") 'bioseq-forward-hundred)

  ;; Define the Bioseq menu
  (define-key bioseq-mode-map [menu-bar] (make-sparse-keymap))
  (let ((menuMap (make-sparse-keymap "Bioseq")))
    (define-key bioseq-mode-map [menu-bar bioseq] (cons "Bioseq" menuMap))

    ;; Menu entries begin here, and run bottom to top because emacs is silly
    (define-key menuMap [compare-seqs]
      '(menu-item "Compare to master" bioseq-compare-seqs
		  :enable (> (length master-sequence) 0)
		  :help "Generate a new line that shows conservation of the
current line to the master sequence"))

    (define-key menuMap [set-master]
      '(menu-item "Set master sequence" bioseq-set-master-sequence
		  :keys "C-c C-m"
		  :help "Set the current line as the master sequence
for comparison"))

    (define-key menuMap [separator4]
      '(menu-item "--single-line"))

    (define-key menuMap [unspace-region]
      '(menu-item "Remove spaces in region" bioseq-remove-spaces-region
		  :enable (use-region-p)
		  :help "Remove spaces between amino acids"))

    (define-key menuMap [unspace-line]
      '(menu-item "Remove spaces on line" bioseq-remove-spaces-line
		  :help "Remove spaces between amino acids"))

    (define-key menuMap [space-region]
      '(menu-item "Space out a.a. in region" bioseq-aa-space-region
		  :enable (use-region-p)
		  :help "Add two spaces after each residue for alignment 
under nucleotide sequence"))

    (define-key menuMap [space-line]
      '(menu-item "Space out a.a. on line" bioseq-aa-space-line
		  :help "Add two spaces after each residue for alignment 
under nucleotide sequence"))

    (define-key menuMap [align-seqs]
      '(menu-item "Align to master from point" bioseq-align-to-master
		  :enable (> (length master-sequence) 0)
		  :help "Insert gaps at beginning of line to align the current
line to the master sequence, matching the 8 residues
following the cursor"))

    (define-key menuMap [separator3]
      '(menu-item "--single-line"))

    (define-key menuMap [translate-region]
      '(menu-item "Translate region" bioseq-translate-region
		  :enable (use-region-p)
		  :help "Translate a line of DNA to amino acids"))

    (define-key menuMap [translate-line]
      '(menu-item "Translate line" bioseq-translate-line
		  :help "Translate a region of DNA to amino acids"))

    (define-key menuMap [rc-region]
      '(menu-item "Reverse complement region" bioseq-reverse-complement-region
		  :enable (use-region-p)
		  :help "Reverse complement a region of DNA"))

    (define-key menuMap [rc-line]
      '(menu-item "Reverse complement line" bioseq-reverse-complement-line
		  :help "Reverse complement a line of DNA"))

    (define-key menuMap [reverse-region]
      '(menu-item "Reverse region" bioseq-reverse-region
		  :enable (use-region-p)
		  :help "Reverse the sequence order of a region"))

    (define-key menuMap [reverse-line]
      '(menu-item "Reverse line" bioseq-reverse-line
		  :help "Reverse the sequence order of a line"))

    (define-key menuMap [complement-region]
      '(menu-item "Complement region" bioseq-complement-region
		  :enable (use-region-p)
		  :help "Complement a region of DNA"))

    (define-key menuMap [complement-line]
      '(menu-item "Complement line" bioseq-complement-line
		  :help "Complement a line of DNA"))

    (define-key menuMap [separator2]
      '(menu-item "--single-line"))

    (define-key menuMap [add-ruler]
      '(menu-item "Add ruler" bioseq-add-ruler
		  :help "Add a sequence length ruler to the current line."))

    (define-key menuMap [separator1]
      '(menu-item "--single-line"))

    (define-key menuMap [convert-to-fasta-n]
      '(menu-item "Convert to FASTA (custom)" bioseq-convert-to-fasta-n
		  :help "Convert a FASTA-ready Bioseq-format file into a
FASTA-format file, with a user-defined number of
characters per line (0 for no line breaks)."))

    (define-key menuMap [convert-to-fasta]
      '(menu-item "Convert to FASTA" bioseq-convert-to-fasta
		  :help "Convert a FASTA-ready Bioseq-format file into a
FASTA-format file."))

    (define-key menuMap [convert-fasta]
      '(menu-item "Convert from FASTA" bioseq-convert-fasta
		  :enable (string-match ".fas" buffer-file-name)
		  :help "Convert a FASTA file into the Bioseq format.
'd' for DNA, 'r' for RNA, 'a' for amino acids."))

  ) ;; Close let statement -- end menu entries
) ;; Close if statement -- end keymap


;; Define the mode! It is a derived mode of Fundamental Mode.
;; There are very likely problems with this section, but it works for me.
(define-derived-mode bioseq-mode fundamental-mode "Biological sequences mode"
  "A major mode for viewing and manipulating DNA and peptide sequences."
  (setq font-lock-defaults '(bioseq-font-lock-keywords))
  (setq mode-name "bioseq")
  (run-hooks 'bioseq-mode-hook)
)

;; Start main function definition section

(defun bioseq-add-ruler (r-input)
  "Add a position count ruler to the current line, which is hopefully empty.
The length is determined by the user."
  (interactive "nLength: ")
  (let (r-length r-count r-div)
    (if (> r-input 99999) (setq r-length 100000) (setq r-length r-input))
    (if (< r-length 0) nil (progn
      (insert "000@")
      (setq r-count 10)
      (setq r-div "")
      (while (<= r-count r-length)
	(let (r-div-length r-numdashes)
	  (setq r-div-length (length r-div))
	  (setq r-numdashes '((0 . "....;....|") (2 . "..;....|")
			      (3 . ".;....|") (4 . ";....|") (5 . "....|")))
	  (insert (cdr (assoc r-div-length r-numdashes))))
	(setq r-div (number-to-string r-count))
	(insert r-div)
	(setq r-count (+ r-count 10))))))
  (beginning-of-line))

;; I don't think this function is being used by anything right now, but
;; I'm leaving it here because I might want to use it in the future.
(defun bioseq-select-line ()
  "Select the current line."
  (interactive)
  (end-of-line)
  (set-mark (line-beginning-position)))

(defun bioseq-translate-region (s-beg s-end)
  "Translate a region of DNA into amino acids. The original sequence is deleted
and replaced."
  (interactive "r")
  (let (s-string s-pos s-codon s-length s-codon-aa)
    ;; s-string holds the original string from the region
    (setq s-string (buffer-substring s-beg s-end))
    (delete-region s-beg s-end)
    (goto-char s-beg)
    (setq s-pos 0)
    (setq s-length (length s-string))
    ;; replace the + with a # to indicate it's not a peptide sequence
    (if (string-equal (substring s-string 3 4) "+")
	(progn (insert (substring s-string 0 3)) (insert "#") (setq s-pos 4)))
    (while (< s-pos s-length)
      (if (< (+ s-pos 2) s-length)
        (progn (setq s-codon (substring s-string s-pos (+ s-pos 3)))
	       ;; Look up the codon (s-codon) in the codon table
	       ;; Save the associated amino acid abbreviation as s-codon-aa
	       (setq s-codon-aa (cdr (assoc s-codon bioseq-codon-table)))
	       ;; above is nil if s-codon is not a valid codon
	       (if s-codon-aa (insert s-codon-aa) (insert "?"))
	       (setq s-pos (+ s-pos 3)))
	(progn (insert "?") (setq s-pos s-length))))))

(defun bioseq-translate-line ()
  "Translate the current line of DNA into amino acids."
  (interactive)
  (bioseq-translate-region (line-beginning-position) (line-end-position))
  (beginning-of-line))

(defun bioseq-complement-region (s-beg s-end)
  "Complement a region of DNA. The original sequence is deleted and replaced."
  (interactive "r")
  (let (s-string s-pos s-codon s-length s-codon-aa)
    ;; s-string holds the original string from the region
    (setq s-string (buffer-substring s-beg s-end))
    (delete-region s-beg s-end)
    (goto-char s-beg)
    (setq s-pos 0)
    (setq s-length (length s-string))
    ;; If we start with a DNA line prefix, keep it
    (if (string-equal (substring s-string 3 4) "+")
	(progn (insert (substring s-string 0 3)) (insert "+") (setq s-pos 4)))
    (while (< s-pos s-length)
      (setq s-res (substring s-string s-pos (+ s-pos 1)))
      ;; Look up the residue in the complement table and store the complement
      ;; as s-res-c, which is nil if the residue is not in the table
      (setq s-res-c (cdr (assoc s-res bioseq-complement-table)))
      (if s-res-c (insert s-res-c) (insert "?"))
      (setq s-pos (+ s-pos 1)))))

(defun bioseq-complement-line ()
  "Complement the current line of DNA."
  (interactive)
  (bioseq-complement-region (line-beginning-position) (line-end-position))
  (beginning-of-line))

(defun bioseq-reverse-region (s-beg s-end)
  "Reverse a region."
  (interactive "r")
  (let (s-string s-pos s-codon s-length s-codon-aa)
    ;; s-string holds the original string from the region
    (setq s-string (buffer-substring s-beg s-end))
    (delete-region s-beg s-end)
    (goto-char s-beg)
    (setq s-pos 0)
    (setq s-length (length s-string))
    (while (< s-pos s-length)
      (insert (substring s-string (- s-length (+ s-pos 1)) (- s-length s-pos)))
      (setq s-pos (+ s-pos 1)))))

(defun bioseq-reverse-line ()
  "Reverse the current line, except for the first 4 characters, which are
the sequence identifiers."
  (interactive)
  (bioseq-reverse-region (+ (line-beginning-position) 4) (line-end-position))
  (beginning-of-line))

(defun bioseq-reverse-complement-region (s-beg s-end)
  "Reverse complement a region of DNA."
  (interactive "r")
  ;; Note that bioseq-complement-region can handle a leading sequence
  ;; identifier, but bioseq-reverse-region cannot.
  (bioseq-complement-region s-beg s-end)
  (bioseq-reverse-region s-beg s-end))
  
(defun bioseq-reverse-complement-line ()
  "Reverse complement a line of DNA."
  (interactive)
  (bioseq-complement-line)
  (bioseq-reverse-line))

(defun bioseq-aa-space-region (s-beg s-end)
  "Space out amino acid sequence so it can be aligned under DNA sequence."
  (interactive "r")
  (let (s-string s-pos s-length)
    (setq s-string (buffer-substring s-beg s-end))
    (delete-region s-beg s-end)
    (goto-char s-beg)
    (setq s-pos 0)
    (setq s-length (length s-string))
    (if (string-equal (substring s-string 3 4) "#") 
	(progn (insert (substring s-string 0 4)) (setq s-pos 4)))
    (while (< s-pos s-length)
      (insert (substring s-string s-pos (+ s-pos 1)))
      (if (= s-pos (- s-length 1)) nil (insert "  "))
      (setq s-pos (+ s-pos 1)))))

(defun bioseq-aa-space-line ()
  "Space out amino acid sequence so it can be aligned under DNA sequence."
  (interactive)
  (bioseq-aa-space-region (line-beginning-position) (line-end-position))
  (beginning-of-line))

(defun bioseq-remove-spaces-region (s-beg s-end)
  "Remove all spaces in selected region. This is to undo bioseq-aa-space-*."
  (interactive "r")
  (let (s-string s-pos s-length s-char)
    (setq s-string (buffer-substring s-beg s-end))
    (delete-region s-beg s-end)
    (goto-char s-beg)
    (setq s-pos 0)
    (setq s-length (length s-string))
    (while (< s-pos s-length)
      (setq s-char (substring s-string s-pos (+ s-pos 1)))
      (if (string-equal s-char " ") nil	(insert s-char))
      (setq s-pos (+ s-pos 1)))))

(defun bioseq-remove-spaces-line ()
  "Remove all spaces on current line. This is to undo bioseq-aa-space-*."
  (interactive)
  (bioseq-remove-spaces-region (line-beginning-position) (line-end-position))
  (beginning-of-line))

(defun bioseq-convert-fasta (seq-type)
  "Convert a FASTA file into the bioseq-mode format."
  ;; This function assumes that the input is a properly-formed FASTA file.
  ;; Behavior with any other format may be unpredictable, but will probably
  ;; just erase everything.
  (interactive "cSequence type (d/r/a): ")
  (let (f-buffer f-seqcount f-lines f-linenum f-moreseq)
    (setq f-buffer (delete-and-extract-region (point-min) (point-max)))
    (goto-char (point-min))
    (setq f-lines (split-string f-buffer "\n" t))
    ; f-lines stores the original file's data as a list of lines
    (setq f-seqcount 0) ; This counts the number of sequences in the file
    (setq f-linenum 0) ; Counts the original file's line number being evaluated
    (while (< f-linenum (length f-lines))
      (if (string-equal ">" (substring (nth f-linenum f-lines) 0 1))
	  (progn (if (= f-seqcount 0) (goto-line 0)
		   (progn (goto-line f-seqcount) (end-of-line) (insert "\n")
			  (goto-line (+ 1 f-seqcount))))
	    (setq f-seqcount (+ 1 f-seqcount))
	    (insert (bioseq-int-to-prefix f-seqcount))
	    (insert (nth f-linenum f-lines))
	    (end-of-buffer)
	    (insert "\n")
	    (insert (bioseq-int-to-prefix f-seqcount))
	    ;; Insert the appropriate code character based on input
	    (if (char-equal seq-type (string-to-char "d"))
		(insert "+")
	      (if (char-equal seq-type (string-to-char "a"))
		  (insert "#")
		(if (char-equal seq-type (string-to-char "r"))
		    (insert "$")
		  (insert "?"))))
	    (setq f-linenum (+ 1 f-linenum))
	    (setq f-moreseq t)
	    ; Are there more lines to be read for this sequence?
	    (while f-moreseq
	      (if (< f-linenum (length f-lines))
		(if (string-equal ">" (substring (nth f-linenum f-lines) 0 1))
		  (setq f-moreseq nil)
		  (progn (insert (nth f-linenum f-lines))
			 (setq f-linenum (+ 1 f-linenum))))
		(setq f-moreseq nil))))
	(setq f-linenum (length f-lines))))) ; To prevent an infinite loop
  (goto-line 0)
  (setq fasta-not-converted nil))

(defun bioseq-int-to-prefix (n-in)
  "Helper function for format conversion. Takes an integer and returns a
three-character string of that number."
  (let (n-out n-in-string n-digits)
    (setq n-in-string (number-to-string n-in))
    (setq n-digits (length n-in-string))
    (setq n-out nil)
    (if (= 1 n-digits) (setq n-out (concat "00" n-in-string)))
    (if (= 2 n-digits) (setq n-out (concat "0" n-in-string)))
    (if (= 3 n-digits) (setq n-out n-in-string))
    (setq n-out n-out))) ; Is there a better way to return the value of n-out?

(defun bioseq-set-master-sequence ()
  "Set the current line as the master sequence for conservation comparisons."
  (interactive)
  (setq master-sequence (buffer-substring (line-beginning-position)
					  (line-end-position))))

(defun bioseq-compare-seqs ()
  "Generate a new line below the current one that shows deviations from the
master sequence."
  (interactive)
  (let (curr-line s-pos m-length c-length s-length curr-line-type)
    (setq curr-line (buffer-substring (line-beginning-position)
				      (line-end-position)))
    (setq s-pos 4)
    (setq m-length (length master-sequence))
    (setq c-length (length curr-line))
    (setq s-length (min m-length c-length))
    (end-of-line)
    (newline)
    (insert (substring curr-line 0 3))
    (setq curr-line-type (aref curr-line 3))
    (if (char-equal curr-line-type (string-to-char "+"))
	(insert "=")
      (if (char-equal curr-line-type (string-to-char "#"))
	  (insert "&")
	(insert "?")))
    (while (< s-pos s-length)
      (if (char-equal (aref master-sequence s-pos) (aref curr-line s-pos))
	  (insert ".")
	(insert (substring curr-line s-pos (+ s-pos 1))))
      (setq s-pos (+ s-pos 1))))
  (beginning-of-line))
    
(defun bioseq-align-to-master ()
  "Insert gaps at beginning of current line to align it to the master sequence,
based on the next few residues at point."
  (interactive)
  (if (> (length master-sequence) 0) ;;Require master sequence to be set
      (let (curr-line curr-col snippet m-pos notdone)
	(setq curr-col (current-column))
	(setq curr-line (buffer-substring (line-beginning-position)
					  (line-end-position)))
	(setq snippet (substring curr-line curr-col (+ curr-col 8)))
	(setq m-pos (+ curr-col 1))
	(setq notdone t)
	;; Search until the end of the master sequence or a match is found
	(while (and (< m-pos (- (length master-sequence) 8)) notdone)
	  (let (num-match check-count)
	    (setq num-match 0) ;; # matching chars in current 8-char window
	    (setq check-count 0) ;; tallies 0 to 8 for each checked char
	    (while (< check-count 8)
	      (if (char-equal (aref master-sequence (+ m-pos check-count))
			      (aref snippet check-count))
		  (setq num-match (+ num-match 1)))
	      (setq check-count (+ check-count 1)))
	    (if (= num-match 8) (progn ;; Only perfect matches count
		(move-to-column 4)
		;; Insert an appropriate number of dashes at line beginning
		(insert-char (string-to-char "-") (- m-pos curr-col))
		(setq notdone nil)))) ;; Match successfully found
	  (setq m-pos (+ m-pos 1)))))
)

(defun bioseq-convert-to-fasta-n (input-n)
  "Convert a properly-formed, FASTA-ready .embs-format file into FASTA format."
  (interactive "nCharacters per line (0 for no line breaks): ")
  (goto-line 1)
  (let (seq-count more-lines process-seq curr-seq seq-linebreak)
    (setq seq-count 0) ;; Number of sequences to be converted
    (setq more-lines t) ;; Are there more lines to process?
    (while more-lines
      (if (string-match "[0-9][0-9][0-9]>"
			(buffer-substring (line-beginning-position)
					  (+ 4 (line-beginning-position))))
	  (progn (setq seq-count (+ 1 seq-count))
		 (setq more-lines (= (forward-line 1) 0)))
	(setq more-lines nil)))
    (if (and (> seq-count 0) (= (goto-line (* seq-count 2)) 0))
	(progn
	  (setq process-seq 1)
	  (while (<= process-seq seq-count)
	    (goto-line (+ 1 (* 2 (- process-seq 1))))
	    (delete-char 3) ;; Delete ### in prefix, but leave >
	    ;; Go to the accompanying sequence line
	    (goto-line (+ 2 (- seq-count process-seq)
			  (* 2 (- process-seq 1))))
	    (if (string-match "[0-9][0-9][0-9]."
			      (buffer-substring (line-beginning-position)
					(+ 4 (line-beginning-position))))
		(delete-char 4))
	    (setq curr-seq (delete-and-extract-region (line-beginning-position)
						      (line-end-position)))
	    (delete-char 1) ;; Remove newline
	    (goto-line (+ 2 (* 2 (- process-seq 1))))
	    (newline)
	    (forward-line -1)
	    (insert curr-seq)
	    (setq process-seq (+ 1 process-seq))
	    ) ;; end while

	  ;; Go to line after sequences, or end of final line
	  (goto-line (+ 1 (* 2 seq-count)))
	  ;; Delete everything that won't be part of the FASTA file
	  (delete-region (point) (point-max))

	  ;; Add line breaks to the sequences for readability.
	  ;; The number of characters per line is given as input-n by the user
	  ;; or by another function.
	  (if (> input-n 0) ;; 0 or negative input-n indicates no line breaks
	      (progn
		;; Count down the sequence number to be processed
		(setq seq-linebreak seq-count)
		(while (> seq-linebreak 0)
		  (goto-line (* 2 seq-linebreak))
		  (let (chars-in-seq pos-in-seq)
		    (setq chars-in-seq (length (buffer-substring 
						(line-beginning-position)
						(line-end-position))))
		    (setq pos-in-seq 0)
		    (while (< (+ pos-in-seq input-n) chars-in-seq)
		      (forward-char input-n)
		      (newline)
		      (setq pos-in-seq (+ pos-in-seq input-n)))
		    ) ;; end let
		  (setq seq-linebreak (- seq-linebreak 1))
		  ) ;; end while
		) ;; end progn
	    ) ;; end if
	  ) ;; end progn
      ) ;; end if
    ) ;; end let
)

(defun bioseq-convert-to-fasta ()
  "Convert properly-formatted file to FASTA format using
bioseq-convert-to-fasta-n with a default value of 60 characters per line."
  (interactive)
  (bioseq-convert-to-fasta-n 60)
)

(defun bioseq-forward-hundred ()
  "Move point forward 100 characters, or to end of line."
  (interactive)
  (if (> (line-end-position) (+ (point) 100))
      (forward-char 100)
    (end-of-line))
)

(defun bioseq-backward-hundred ()
  "Move point backwards 100 characters, or to beginning of line."
  (interactive)
  (if (< (line-beginning-position) (- (point) 100))
      (forward-char -100)
    (beginning-of-line))
)

;; End function definitions

(add-hook 'bioseq-mode-hook (lambda () (setq truncate-lines t)))

(provide 'bioseq)
